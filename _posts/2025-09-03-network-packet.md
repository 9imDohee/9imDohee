---
title: "[Network] Packet"
excerpt: "Pack it!"

categories:
  - Categories1
tags:
  - [tag1, tag2]

permalink: /categories1/post-name-here/

toc: true
toc_sticky: true

date: 2025-09-03
last_modified_at: 2025-09-4
---
## 1. 패킷(Packet)이란?
: 네트워크에서 **데이터를 전송할 때 잘게 쪼갠 작은 단위**
- 각각의 패킷은 **출발지, 목적지, 순서 정보, 데이터 조각**을 포함
- **왜 필요한가:** 큰 데이터를 한 번에 보내면 오류나 재전송 비용이 크기 때문에, 작은 단위로 나누어 신뢰성을 확보

**[패킷 통신의 특징]**
1) 효율성: 데이터를 잘게 나눠서 여러 경로로 동시에 전송 가능
2) 신뢰성:  일부 패킷이 손실돼도 재전송 요청 가능 (TCP 등)
3) 유연성:  패킷은 네트워크 상황에 따라 서로 다른 경로를 통해 목적지에 도달 가능
4) 순서 보장:  TCP 같은 전송 계층 프로토콜이 패킷을 재조합해 원래 데이터 복구

<br/>

## 2. 패킷의 구조
패킷은 보통 헤더(Header) + 데이터(Data) + 트레일러(Trailer, 필요 시)로 구성됨

1. **헤더 (Header)**
   패킷에 대한 제어 정보 포함
   e.g. 송·수신 IP 주소, 프로토콜 정보, 순서 번호, 오류 검출 코드 등
    
  - 어떤 프로토콜이냐에 따라 헤더가 다름
      - **IP 패킷:** 출발지/목적지 IP, TTL, 프로토콜 번호 등
       - **TCP 세그먼트:** 출발지/목적지 포트, 시퀀스 번호, ACK 번호, 플래그
       - **UDP 데이터그램:** 포트, 길이, 체크섬
       
2. **데이터 (Payload)**
실제 전송하려는 내용 (웹 페이지 데이터, 영상 조각, 메시지 텍스트 등)

3. **트레일러(Trailer, 선택적)**
 데이터 무결성 확인용 (예: CRC 에러 체크)
<br/>
## 3. 패킷의 전송 과정


1. **데이터 분할 (Segmentation & Packetization)**
애플리케이션에서 전송하려는 큰 데이터를 네트워크 전송 단위인 패킷으로 잘게 나눔

2. **헤더 추가 (Encapsulation, 캡슐화)**
![](https://velog.velcdn.com/images/do_e/post/086e075a-54ae-43b9-bc86-e3058366c11d/image.png)
각 계층에서 필요한 제어 정보를 헤더로 붙임

- 전송 계층 (TCP/UDP): 포트 번호, 순서 번호, 오류 검출 코드 등 추가
- 네트워크 계층 (IP): 송·수신 IP 주소 추가
- 데이터 링크 계층 (Ethernet 등): MAC 주소, 프레임 트레일러(CRC) 추가
→ 최종적으로 프레임(Frame)이 되어 물리 계층으로 내려감

3. **물리적 전송 (Physical Transmission)**

- 0과 1(비트)이 전기 신호, 광 신호, 전파 등으로 변환되어 케이블/무선 채널을 통해 전송됨
- 패킷 자체가 아니라 패킷의 내용이 비트 신호로 네트워크 매체를 따라 이동

4. **라우터 & 스위치에서 전달 (Routing & Switching)**

- 스위치 (Data Link 계층): MAC 주소 기반으로 같은 네트워크 안에서 전달
- 라우터 (Network 계층): IP 주소 기반으로 다른 네트워크로 전달
- 패킷은 목적지까지 갈 때 여러 네트워크 장비를 거칠 수 있음 (경로 = 홉 Hop)

5. **수신 측에서 역캡슐화 (Decapsulation)**

- 패킷이 목적지에 도착하면 각 계층이 순서대로 헤더를 제거하면서 상위 계층에 전달
    - 데이터 링크 계층 → IP 패킷 전달
    - 네트워크 계층 → TCP/UDP 세그먼트 전달
    - 전송 계층 → 애플리케이션 데이터 전달
    
6. **데이터 재조립 (Reassembly)**
- 여러 패킷으로 쪼개진 데이터를 순서대로 다시 합침
- TCP는 순서 번호를 이용해 올바른 순서대로 재조립 + 손실된 패킷은 재전송 요청
- UDP는 순서 보장 없이 도착한 대로 애플리케이션에 전달


<br/>

## 4. 패킷 흐름과 캡슐화
[이미지 출처](http://computernetworkingnotes.com/ccna-study-guide/data-encapsulation-and-de-encapsulation-explained.html)

![](https://velog.velcdn.com/images/do_e/post/d6ed9614-b39f-4fd3-ba48-c262a171430c/image.png)

### 캡슐화 (Encapsulation)
:데이터를 보낼 때 상위 계층의 데이터를 하위 계층으로 내려보내면서 계층별로 헤더(또는 트레일러)를 붙이는 과정

1. **응용 계층 (Application Layer)**
    - 사용자가 입력한 메시지나 파일 같은 데이터가 준비됨
    - e.g. 웹 브라우저에서 작성한 HTTP 요청
2. **전송 계층 (Transport Layer)**
    - 데이터에 TCP/UDP 헤더를 붙임 (포트 번호, 순서 번호, 오류 제어 등 포함)
    -> **세그먼트(Segment)**
3. **네트워크 계층 (Network Layer)**
    - 세그먼트에 IP 헤더를 추가 (출발지/목적지 IP 주소 포함)
    -> **패킷(Packet)**
4. **데이터 링크 계층 (Data Link Layer)**
    - 패킷에 MAC 주소 정보가 담긴 프레임 헤더 + 오류 검출용 트레일러를 붙임
    ->**프레임(Frame)**
5. **물리 계층 (Physical Layer)**
    - 프레임을 0과 1의 **비트 스트림**으로 변환해서 전기 신호, 광 신호, 전파로 전송
    
### 역캡슐화 (Decapsulation)
: 수신 측에서 데이터를 받으면서 각 계층의 헤더/트레일러를 벗겨내는 과정

1. **물리 계층**: 전기/광/무선 신호 → 비트로 변환
2. **데이터 링크 계층**: 프레임 → 오류 검사 후 헤더/트레일러 제거 → **패킷 추출**
3. **네트워크 계층**: IP 주소 확인, 경로 확인 후 헤더 제거 → **세그먼트 추출**
4. **전송 계층**: 포트 번호 확인, 순서/재조립, 오류 검사 후 헤더 제거 → **데이터 추출**
5. **응용 계층**: 최종적으로 사용자가 이해할 수 있는 데이터로 제공 e.g. 웹페이지 표시


<br/>

---
## 5.MTU(Maximum Transmission Unit)
**조각화 (Fragmentation)**
MTU: 전송할 수 있는 **네트워크 프레임/패킷의 최대 크기**
- **단위: 바이트**
  이더넷(Ethernet) → 일반적으로 **1500바이트**
  PPPoE → **1492바이트**
  IPv6에서는 **최소 MTU = 1280바이트**로 정의
  MTU보다 큰 데이터를 보내려면 조각화 필요

### 조각화 (Fragmentation)

: 네트워크 계층(IP 계층)에서 패킷이 MTU보다 클 때 패킷을 잘라서 전송하는 과정

- 수신 측에서 다시 조립(재조립, reassembly)해야 원래 데이터가 됨
1. **송신 측**: 데이터 크기가 MTU 초과 → 패킷을 여러 개로 조각화(fragment)
2. **경유 라우터**: 경로상 다른 네트워크의 MTU가 더 작을 경우 → 중간에서 조각화 발생 가능
3. **수신 측**: 조각난 패킷들을 다시 모아서 원래 패킷으로 재조립

<br/>

---
## 6. 라우팅과 TTL
- 라우팅: 패킷이 **"어디로 갈지"** 결정하는 과정
- TTL(Time To Live): 패킷이 얼마나 갈 수 있는지를 제한하는 장치 
- 둘이 함께 동작하면서 네트워크 안정성과 효율성을 유지함

### 라우팅 (Routing)
: 네트워크에서 패킷이 목적지까지 가는 최적의 경로를 찾는 과정
패킷은 송신지에서 목적지까지 직접 가는 게 아니라 라우터(router)를 거쳐 전달됨
라우터는 각 패킷의 목적지 IP를 보고, 어느 다음 홉으로 보내야 할지 판단

### ## TTL (Time To Live)
: IP 패킷 헤더에 있는 필드 (숫자 카운터)
패킷이 네트워크에서 **"얼마나 오래 살아남을 수 있는지"**를 정함
단위: **홉(hop, 라우터를 1개 지날 때마다 1씩 감소)**
- 송신지에서 패킷을 보낼 때 TTL 값이 설정됨 (e.g. 기본 64, 128, 255 등 운영체제별로 다름)
-  라우터를 거칠 때마다 TTL이 1 감소
-  TTL이 0이 되면 라우터는 패킷을 폐기 & 송신지에 ICMP Time Exceeded 메시지를 보냄

**[왜 사용하는가?]**
무한 루프 방지: 라우팅 테이블 오류로 패킷이 계속 무한히 떠돌지 않게 생명주기를 제한함
네트워크 진단 도구 활용: traceroute 명령어는 TTL 값을 점진적으로 증가시키며 패킷을 보내면서 경유 라우터의 IP를 역으로 추적

### 라우팅과 TTL의 관계
- 패킷이 라우터를 거치면서 경로를 따라 이동 (TTL 감소)
- TTL을 사용하여 잘못된 라우팅 루프에 빠져도 패킷이 무한적으로 떠돌지 않음
- TTL은 라우팅 과정의 안전 장치 역할을 함 (라우팅 과정에서 TTL이 항상 관여)